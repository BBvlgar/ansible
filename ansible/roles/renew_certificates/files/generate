#!/bin/bash -e

# COMMAND LINE AGRS
TYPE="$1"
EMAIL="$2"              # email address
CN="$3"                 # common name
CA_PASSWD="$4"          # ca private key passphrase
KEY_PASSWD="$5"         # new certificate private key passphrase
RENEW="$6"

# GLOBAL VARS
PKI_ROOT=/home/sysadmin/Private/it-economics_CA
PKI_ROOT_CA=$PKI_ROOT/ca/it-economics_CA.crt
KEY_ROOT=$PKI_ROOT/$TYPE/$EMAIL
REQEXTS=local_ca_${TYPE}_reqexts
EXTENSIONS=local_ca_${TYPE}_extensions
STUB=it-economics_$EMAIL

# USAGE
SCRIPTNAME="generate"
USAGE="Usage: $SCRIPTNAME [internal|external|server] [e-mail adress|server common name] [common name/full name] [opt: CA private key password] [opt: New private key password] [opt: renew]

\ne.g.: $SCRIPTNAME internal tklein@it-economics.de 'Torsten Klein'
\ne.g.: $SCRIPTNAME external mathias.menzel.extern@it-economics.de 'Mathias Menzel' Def12345 Admin123
\ne.g.: $SCRIPTNAME server minimal.muc.it-economics.de
"

# Exports for OpenSSL
export CN
export EMAIL
export OPENSSL_CONF=$PKI_ROOT/ca/it-economics_CA.cnf

# Define return codes
OK=0
FAIL=1
WARN=2
SKIP=3

log() {
    local prefix="ERROR"
    case $1 in
        0)
            prefix="INFO"
        ;;
        *)
            prefix="ERROR"
        ;;
    esac
    echo $(date --rfc-3339=seconds) $prefix: $2
    
    if [ $1 -ne 0 ] ; then
        exit 1
    fi
}

# Sanity checks
sanity() {
  if [ -z "$1" ] ; then
    echo -e $USAGE
    exit 1
  else
    for i in $@ ; do
      if [ -z "$i" ] ; then
        echo -e $USAGE
        exit 1
      fi
    done
  fi

  if [ -z "$RENEW" ]; then
    if [ -e $KEY_ROOT ]; then
      cat <<EOT
"$KEY_ROOT" exists.

Which means you should revoke this certificate and take it from there.
!!! CAUTION !!!
Alternatively you can remove it in order to generate new keys, if you think this is ok. Then you will have to edit index.txt and serial file content. Also the signedcertificates numbering has to be aligned with index.txt content.
!!! /CAUTION !!!
  
EOT
      exit 1
    fi
  else
    if ! [[ -e $KEY_ROOT ]]; then
      cat <<EOT

"$KEY_ROOT" does not exist. Cannot renew.
EOT
      exit 1
    fi

  fi
}

# Sets global PASSWD
getPasswd() {
  local NEW_PASSWORD=""
  local NEW_PASSWORD_ACK=""
  local QUESTION="$1"
  
  # Reset
  unset PASSWD
  
  # Read
  echo ""
  echo -n "$QUESTION" ": "
  read -s NEW_PASSWORD
  echo ""
  echo -n "Please enter password again: "
  read -s NEW_PASSWORD_ACK
  echo ""
  
  if ! [ "$NEW_PASSWORD_ACK" == "$NEW_PASSWORD" ] ; then
    echo "Passwords do not match, please try again."
    getPasswd "$QUESTION"
  else
    # Set global liferay user password
    PASSWD="$NEW_PASSWORD"
    return $OK
  fi
}
renewKey() {
    PWEXT=""

    case $TYPE in
        server)
        CN="$CN"
        KEYINFX=".nopass"
        ;;
        internal|external)
        # CN="$CN, $EMAIL"
        CN="$CN"
    ;;
    *)
    ;;
    esac

    export CN
    export EMAIL
    DT=$(date --rfc-3339=seconds | sed 's/ /\_/')

    echo "--- Renewing $KEY_ROOT with CN: $CN ---"
    cd $KEY_ROOT
    # copy new CA
    cp $PKI_ROOT_CA .

    # save old files (both client server)
    for X in .zip .csr .crt .p12 .crt.sha256 .crt.crl .cer; do
        if [ -e ${STUB}${X} ]; then
          mv ${STUB}${X} ${STUB}${X}.${DT}
        fi
    done

    # new CSR
    openssl req -batch -passin pass:"$KEY_PASSWD" -passout pass:"$KEY_PASSWD" -new -key ${STUB}${KEYINFX}.key -reqexts $REQEXTS -out ${STUB}.csr
    log  $? "Creating CSR ${STUB}.csr"

    # sign key
    openssl ca -passin pass:"$CA_PASSWD" -batch -extensions $EXTENSIONS -in ${STUB}.csr -out ${STUB}.crt
    log  $? "Create CRT ${STUB}.crt"

    # verify key
    openssl verify -CAfile it-economics_CA.crt ${STUB}.crt
    log  $? "Verify CRT ${STUB}.crt"

    # create CER file
    openssl x509 -in ${STUB}.crt -outform DER -out ${STUB}.cer
    log  $? "Create CER ${STUB}.cer"

    if ! [ "$TYPE" == "server" ]; then
        # create pkcs12 and zip
        openssl pkcs12 -passin pass:"$KEY_PASSWD" -passout pass:"$KEY_PASSWD" -export -inkey ${STUB}.key -in ${STUB}.crt -name "it-economics PKCS#12 ${EMAIL}" -out ${STUB}.p12 $PASS_OUT_KEY
        log  $? "Generate pkcs12 ${STUB}.p12"

        zip -j ${STUB}.zip -P "$KEY_PASSWD" it-economics_CA.crt ${STUB}.crt ${STUB}.cer ${STUB}.p12
        log  $? "Zip and Remove pkcs12 ${STUB}.p12"
    else
        # revocation list
        openssl ca -passin pass:"$CA_PASSWD" -gencrl -out ${STUB}.crl
        log  $? "Create revocation list ${STUB}.crl"
        
        zip -j ${STUB}.zip it-economics_CA.crt ${STUB}.crt ${STUB}.crl
        log  $? "Zip ${STUB}.crl"
    fi
}

createKey() {
	mkdir -p $KEY_ROOT
    log  $? "Creating $KEY_ROOT with CN: $CN"

	cd $KEY_ROOT
    log $? "Changing workdir to $KEY_ROOT"

    # new key
	openssl req -batch -passin pass:"$KEY_PASSWD" -passout pass:"$KEY_PASSWD" -newkey rsa:4096 -reqexts $REQEXTS -keyout ${STUB}.key -keyform PEM -out ${STUB}.csr -outform PEM $PASS_OUT_KEY
    log $? "Generating new key ${STUB}.key with specified phassphrase and creating CSR ${STUB}.csr"
	
    # sign key and verify
    openssl ca -passin pass:"$CA_PASSWD" -batch -extensions $EXTENSIONS -in ${STUB}.csr -out ${STUB}.crt
	log $? "Handling CSR ${STUB}.csr with CA from $PKI_ROOT"

	openssl verify -CAfile $PKI_ROOT_CA ${STUB}.crt
	log $? "Verifying new certificate against CA $PKI_ROOT_CA"

    # create pub and nopass keys
	openssl rsa -passin pass:"$KEY_PASSWD" -passout pass:"$KEY_PASSWD" -in ${STUB}.key $PASS_IN_KEY -out ${STUB}.nopass.key
    openssl rsa -in ${STUB}.nopass.key -pubout > ${STUB}.pub
    log $? "Generate pub key ${STUB}.pub and nopass key ${STUB}.nopass.key"
	
	chmod 400 ${STUB}*.key
	
    ssh-keygen -y -f ${STUB}.nopass.key > ${STUB}.nopass.key.pub

}

server() {
  openssl dhparam -out dh1024.pem 1024
  openssl ca -passin pass:"$CA_PASSWD" -gencrl -out ${STUB}.crl

  zip -j ${STUB}.zip $PKI_ROOT_CA ${STUB}.crt ${STUB}.nopass.key ${STUB}.crl dh1024.pem
}

client() {
  local TYPE=$1

  # generate PKCS#12 file for SSLClientVerify Auth
  openssl pkcs12 -passin pass:"$KEY_PASSWD" -passout pass:"$KEY_PASSWD" -export -inkey ${STUB}.nopass.key -in ${STUB}.crt -name "it-economics PKCS#12 ${EMAIL}" -out ${STUB}.p12 $PASS_OUT_KEY

  # we go for more security and delete nopass
  rm -f ${STUB}.nopass.key

  zip -j ${STUB}.zip -P "$KEY_PASSWD" $PASS_OUT_ZIP $PKI_ROOT_CA ${STUB}.crt ${STUB}.key ${STUB}.p12

  case $TYPE in
	# Pack openvpn config only for internal employees
	"internal")
        for file in `ls -1 ${PKI_ROOT}/openvpn/`; do
            BASE=${file##*/}
            sed -e "s/USERNAME/${EMAIL}/g" $file > ${BASE/\./_${EMAIL}.}
            zip -j -P "$KEY_PASSWD" ${STUB}.zip $PASS_OUT_ZIP ${BASE/\./_${EMAIL}.}
        done
	;;
	*)
	;;
  esac
}

# Check if $EMAIL is a valid e-mail adress
validateEmail() {
    echo "$EMAIL" | grep -E "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b" > /dev/null
    log $? "Checking if $EMAIL is valid"
}
############# main ############
sanity $@
validateEmail

if [ -z "$CA_PASSWD" ] ; then
  # get CA password
  echo "Please enter password for __CA__ private key"
  read -s CA_PASSWD
else
  echo "Using CA private key password supplied on command line"
fi

# key_passwd only needed when new key
if [ -z "$RENEW" ] ; then
	if [ -z "$KEY_PASSWD" ] ; then
  	# get key/zip password
  	getPasswd "Please enter password for new __"$TYPE"__ private key"
  	KEY_PASSWD="$PASSWD"
	else
  	echo "Using $TYPE private key password supplied on command line"
	fi
fi

if [ -n "$RENEW" ] ; then
  case "$TYPE" in
    "server")
      printf "\n!!!!!!!!!!!!!\nvpn-hq NEEDS keyUsage, all other servers do not work with keyUsage. Please check config\n!!!!!!!!!!!!!\n"
      STUB=$EMAIL
    ;;
    *)
	;;
  esac
  echo $STUB
  renewKey
else
	case "$TYPE" in
        "server")
            printf "\n!!!!!!!!!!!!!\nvpn-hq NEEDS keyUsage, all other servers do not work with keyUsage. Please check config\n!!!!!!!!!!!!!\n"
            STUB="$EMAIL"
            EMAIL="sysadmin@it-economics.de"
            createKey
            server
        ;;
        "internal")
            validateEmail $EMAIL
            createKey
            client "$TYPE"
        ;;
        "external")
            validateEmail $EMAIL
            createKey
            client "$TYPE"
        ;;
        *)
            echo $USAGE
            exit 1
        ;;
	esac
fi
###########################


cd -
