#!/bin/bash -e
#### Instance User data ####
# stackName

# sysLogs

# region
# dataVolume

# externalPort
# externalSecurePort

# sleepInterval

# application
# applicationLogs
# image
# baseUrl
# javaOpts
# efsMountPoint
# datacenterMode

# databaseEndpoint
# databaseName
# databaseArguments
# databaseUsername
#############################

# Source functions
source launch-config-functions.sh

# Get instance user data
user_data=$(mktemp)
curl -s http://169.254.169.254/latest/user-data > $user_data
source $user_data
rm $user_data

######## Define global vars ####
# Container dirs
containerDir=/var/atlassian/application-data/$application
hostDir=/mnt/data
hostSharedDir=/mnt/shared
clusterTagKey=Cluster
clusterTagValue=$stackName

# Executables
AWS=/usr/local/bin/aws

# Startup parameter
initState=$1

############ MAIN #############

log "INFO: Updating awslogs config to match current stack and host and starting service"
updateAwsLogs $sysLogs $application $applicationLogs

# Wait for stack to complete
for period in {1..120} ; do
  case $(getStackStatus $stackName) in
    # TODO Rollback & Cleanup Complete?
    UPDATE_COMPLETE|CREATE_COMPLETE|UPDATE_ROLLBACK_COMPLETE)
      log "INFO: Stack complete"
      break
    ;;
    *)
      log "INFO: Waiting for stack $stackName which is in status $status (period $period of 120)..."
    ;;
  esac
  if [ $period -eq 120 ] ; then
    log "ERROR: Stack $stackName could not be successfully created"
    exit 1
  fi
  sleep $sleepInterval
done


# Ensure directory exists
mkdir -p $hostDir
mkdir -p $hostSharedDir

# Mount shared volume
mount | grep $hostSharedDir > /dev/null 2>&1 3>&1 || mount -t efs -o tls,accesspoint=$efsAccesspoint $efsFilesystemID:/ $hostSharedDir
log "INFO: Mounted $efsAccesspoint in $hostSharedDir"


for period in {1..10} ; do
 set +e
 service docker status | grep 'active (running)' > /dev/null 3>&1 2>&1
 status=$?
 set -e
 if [ $status -eq 0 ] ; then
   break
 fi
 log "INFO: Waiting for docker service do become available (period $period of 10)..."
 sleep $sleepInterval

 if [ $period -eq 10 ] ; then
    log "ERROR: Service docker did not become available in time, aborting"
    exit 1
 fi

done

case $initState in
  start)
    log "INFO: Cleaning up old container for $application if exists"
    set +e
    docker stop $application
    docker rm $application
    set -e

    # setup database
    if [ "$datacenterMode" == true ]; then
      if [ "$application" == "jira" ]; then
        jiraSetClusterConfig "$databaseEndpoint" "$databaseName" "$databaseArguments" "$databaseUsername" "$hostDir" "$hostSharedDir" "$stackName"
      elif [ "$application" == "confluence" ]; then
        confluenceSetClusterConfig "$databaseEndpoint" "$databaseName" "$databaseArguments" "$databaseUsername" "$clusterTagKey" "$clusterTagValue" "$stackName" "$hostDir"
      elif [ "$application" == "bitbucket" ]; then
        bitbucketSetClusterConfig "$databaseEndpoint" "$databaseName" "$databaseArguments" "$databaseUsername" "$clusterTagKey" "$clusterTagValue" "$stackName" "$hostDir"
      fi
    else
      updateDatabaseEndpoint "$application" "$databaseEndpoint" "$databaseName" "$databaseArguments" "$hostSharedDir"
    fi

    # register EC2 on Sophos Central and change used threads
    /opt/sophos-av/engine/registerMCS {{ sophos_register_token }} {{ sophos_register_url }}
    setSophosThreads

    chown -R ubuntu:ubuntu $hostDir
    chown -R ubuntu:ubuntu $hostSharedDir

    # Start container
    log "INFO: Starting container with image $image on port $externalPort (http) and $externalSecurePort (https)"

    if [ "$datacenterMode" == true ]; then
      if [ "$application" == "bitbucket" ]; then
        docker run \
          -d \
          -v "$hostDir":"$containerDir" \
          -p "$externalPort":"8080" \
          -p "$externalSecurePort":"8443" \
          -p "0.0.0.0:7999:7999" \
          -e "PROXY=$baseUrl" \
          -e "JAVA_OPTS=$javaOpts" \
          -e "CATALINA_OPTS=$javaOpts" \
          -e "CHOWN_DEBUG=true" \
          -v /etc/timezone:/etc/timezone:ro \
          -v /etc/localtime:/etc/localtime:ro \
          --name $application \
          --log-driver=awslogs \
          --log-opt awslogs-region=$region \
          --log-opt awslogs-group=$applicationLogs \
          --log-opt awslogs-stream=$application \
        $image
      else
        #confluence and jira configuration
        docker run \
          -d \
          -v "$hostDir":"$containerDir" \
          -v "$hostSharedDir":"/shared" \
          -e "PROXY=$baseUrl" \
          -e "JAVA_OPTS=$javaOpts" \
          -e "CATALINA_OPTS=$javaOpts" \
          -e "CHOWN_DEBUG=true" \
          -v /etc/timezone:/etc/timezone:ro \
          -v /etc/localtime:/etc/localtime:ro \
          --name $application \
          --network host \
          --log-driver=awslogs \
          --log-opt awslogs-region=$region \
          --log-opt awslogs-group=$applicationLogs \
          --log-opt awslogs-stream=$application \
        $image
      fi
    else
      if [ "$application" == "bitbucket" ]; then
        #confluence and jira configuration
        docker run \
          -d \
          -v "$hostSharedDir":"$containerDir" \
          -p "$externalPort":"8080" \
          -p "$externalSecurePort":"8443" \
          -p "0.0.0.0:7999:7999" \
          -e "PROXY=$baseUrl" \
          -e "JAVA_OPTS=$javaOpts" \
          -e "CATALINA_OPTS=$javaOpts" \
          -e "CHOWN_DEBUG=true" \
          -v /etc/timezone:/etc/timezone:ro \
          -v /etc/localtime:/etc/localtime:ro \
          --name $application \
          --log-driver=awslogs \
          --log-opt awslogs-region=$region \
          --log-opt awslogs-group=$applicationLogs \
          --log-opt awslogs-stream=$application \
        $image
      else
        #confluence and jira configuration
        docker run \
          -d \
          -v "$hostSharedDir":"$containerDir" \
          -p "$externalPort":"8080" \
          -p "$externalSecurePort":"8443" \
          -e "PROXY=$baseUrl" \
          -e "JAVA_OPTS=$javaOpts" \
          -e "CATALINA_OPTS=$javaOpts" \
          -e "CHOWN_DEBUG=true" \
          -v /etc/timezone:/etc/timezone:ro \
          -v /etc/localtime:/etc/localtime:ro \
          --name $application \
          --log-driver=awslogs \
          --log-opt awslogs-region=$region \
          --log-opt awslogs-group=$applicationLogs \
          --log-opt awslogs-stream=$application \
        $image
      fi
    fi
    ;;
  stop)
    log "INFO: Stopping and deleting container $application"
    docker stop $application
    docker rm $application
    ;;
  *)
    log "INFO: Valid options are: start, stop"
    ;;
esac
